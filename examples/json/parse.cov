// JSON Parsing Example
// Demonstrates parsing JSON and extracting data

// ============================================================
// External JSON Functions (from std.json)
// ============================================================

snippet id="json.parse" kind="extern-abstract"

signature
  fn name="parse"
    param name="input" type="String"
    returns union
      type="Json"
      type="JsonError"
    end
  end
end

metadata
  description="Parse JSON string into Json type. Returns JsonError on invalid syntax."
  cost_hint=moderate
end

end


snippet id="json.get_field" kind="extern-abstract"

signature
  fn name="get_field"
    param name="obj" type="Json"
    param name="key" type="String"
    returns type="Json" optional
  end
end

metadata
  description="Extract field from JSON object. Returns none if not an object or key missing."
end

end


snippet id="json.as_string" kind="extern-abstract"

signature
  fn name="as_string"
    param name="value" type="Json"
    returns type="String" optional
  end
end

metadata
  description="Extract string value from Json::String variant. Returns none for other types."
end

end


snippet id="json.get_index" kind="extern-abstract"

signature
  fn name="get_index"
    param name="arr" type="Json"
    param name="index" type="Int"
    returns type="Json" optional
  end
end

metadata
  description="Extract element from JSON array. Returns none if not an array or index out of bounds."
end

end


// ============================================================
// Example Functions
// ============================================================

snippet id="examples.json_parse" kind="fn"

// Note: Returns String on success, JsonError on failure.
// Using Any return type for simplified example.

signature
  fn name="parse_user_data"
    param name="json_str" type="String"
    returns type="Any"
  end
end

body
  // Parse JSON string
  step id="s1" kind="call"
    fn="json.parse"
    arg name="input" from="json_str"
    as="result"
  end

  // Handle parse result
  step id="s2" kind="match"
    on="result"
    case variant type="JsonError" bindings=("err")
      step id="s2a" kind="return"
        from="err"
        as="_"
      end
    end
    case variant type="Json" bindings=("json_val")
      // Extract name field
      step id="s2b" kind="call"
        fn="json.get_field"
        arg name="obj" from="json_val"
        arg name="key" lit="name"
        as="name_field"
      end

      // Convert to string
      step id="s2c" kind="call"
        fn="json.as_string"
        arg name="value" from="name_field"
        as="name_opt"
      end

      // Handle optional name
      step id="s2d" kind="match"
        on="name_opt"
        case variant type="Some" bindings=("name")
          step id="s2d1" kind="return"
            from="name"
            as="_"
          end
        end
        case variant type="None"
          step id="s2d2" kind="return"
            variant type="JsonError::InvalidType"
              field name="expected" lit="string"
              field name="actual" lit="missing or wrong type"
            end
            as="_"
          end
        end
        as="_"
      end
    end
    as="_"
  end
end

end


snippet id="examples.json_parse_nested" kind="fn"

// Note: This example demonstrates JSON navigation without full error handling.
// In production code, you would match on the union return from json.parse.

signature
  fn name="parse_nested_data"
    param name="json_str" type="String"
    returns type="Any"
  end
end

body
  // Parse JSON string
  step id="s1" kind="call"
    fn="json.parse"
    arg name="input" from="json_str"
    as="result"
  end

  // Navigate: result.user.profile.displayName
  step id="s2" kind="call"
    fn="json.get_field"
    arg name="obj" from="result"
    arg name="key" lit="user"
    as="user_obj"
  end

  step id="s3" kind="call"
    fn="json.get_field"
    arg name="obj" from="user_obj"
    arg name="key" lit="profile"
    as="profile_obj"
  end

  step id="s4" kind="call"
    fn="json.get_field"
    arg name="obj" from="profile_obj"
    arg name="key" lit="displayName"
    as="name_field"
  end

  step id="s5" kind="call"
    fn="json.as_string"
    arg name="value" from="name_field"
    as="name"
  end

  step id="s6" kind="return"
    from="name"
    as="_"
  end
end

end


snippet id="examples.json_parse_array" kind="fn"

// Note: This example demonstrates array access without full error handling.
// In production code, you would match on the union return from json.parse.

signature
  fn name="parse_array_data"
    param name="json_str" type="String"
    returns type="Any"
  end
end

body
  // Parse JSON array
  step id="s1" kind="call"
    fn="json.parse"
    arg name="input" from="json_str"
    as="result"
  end

  // Get first element
  step id="s2" kind="call"
    fn="json.get_index"
    arg name="arr" from="result"
    arg name="index" lit=0
    as="first_elem"
  end

  // Extract as string
  step id="s3" kind="call"
    fn="json.as_string"
    arg name="value" from="first_elem"
    as="str_val"
  end

  step id="s4" kind="return"
    from="str_val"
    as="_"
  end
end

end
